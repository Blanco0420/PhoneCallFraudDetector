// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/address"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/business"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/caller"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/carrier"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/comment"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/linetype"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/number"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/predicate"
	"github.com/Blanco0420/Phone-Number-Check/backend/ent/provider"
	"github.com/Blanco0420/Phone-Number-Check/backend/providers"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress  = "Address"
	TypeBusiness = "Business"
	TypeCaller   = "Caller"
	TypeCarrier  = "Carrier"
	TypeComment  = "Comment"
	TypeLineType = "LineType"
	TypeNumber   = "Number"
	TypeProvider = "Provider"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Prefecture     *string
	_City           *string
	_Postcode       *string
	clearedFields   map[string]struct{}
	business        *int
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*Address, error)
	predicates      []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrefecture sets the "Prefecture" field.
func (m *AddressMutation) SetPrefecture(s string) {
	m._Prefecture = &s
}

// Prefecture returns the value of the "Prefecture" field in the mutation.
func (m *AddressMutation) Prefecture() (r string, exists bool) {
	v := m._Prefecture
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefecture returns the old "Prefecture" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPrefecture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefecture: %w", err)
	}
	return oldValue.Prefecture, nil
}

// ClearPrefecture clears the value of the "Prefecture" field.
func (m *AddressMutation) ClearPrefecture() {
	m._Prefecture = nil
	m.clearedFields[address.FieldPrefecture] = struct{}{}
}

// PrefectureCleared returns if the "Prefecture" field was cleared in this mutation.
func (m *AddressMutation) PrefectureCleared() bool {
	_, ok := m.clearedFields[address.FieldPrefecture]
	return ok
}

// ResetPrefecture resets all changes to the "Prefecture" field.
func (m *AddressMutation) ResetPrefecture() {
	m._Prefecture = nil
	delete(m.clearedFields, address.FieldPrefecture)
}

// SetCity sets the "City" field.
func (m *AddressMutation) SetCity(s string) {
	m._City = &s
}

// City returns the value of the "City" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m._City
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "City" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "City" field.
func (m *AddressMutation) ClearCity() {
	m._City = nil
	m.clearedFields[address.FieldCity] = struct{}{}
}

// CityCleared returns if the "City" field was cleared in this mutation.
func (m *AddressMutation) CityCleared() bool {
	_, ok := m.clearedFields[address.FieldCity]
	return ok
}

// ResetCity resets all changes to the "City" field.
func (m *AddressMutation) ResetCity() {
	m._City = nil
	delete(m.clearedFields, address.FieldCity)
}

// SetPostcode sets the "Postcode" field.
func (m *AddressMutation) SetPostcode(s string) {
	m._Postcode = &s
}

// Postcode returns the value of the "Postcode" field in the mutation.
func (m *AddressMutation) Postcode() (r string, exists bool) {
	v := m._Postcode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostcode returns the old "Postcode" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPostcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostcode: %w", err)
	}
	return oldValue.Postcode, nil
}

// ClearPostcode clears the value of the "Postcode" field.
func (m *AddressMutation) ClearPostcode() {
	m._Postcode = nil
	m.clearedFields[address.FieldPostcode] = struct{}{}
}

// PostcodeCleared returns if the "Postcode" field was cleared in this mutation.
func (m *AddressMutation) PostcodeCleared() bool {
	_, ok := m.clearedFields[address.FieldPostcode]
	return ok
}

// ResetPostcode resets all changes to the "Postcode" field.
func (m *AddressMutation) ResetPostcode() {
	m._Postcode = nil
	delete(m.clearedFields, address.FieldPostcode)
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *AddressMutation) SetBusinessID(id int) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *AddressMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *AddressMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *AddressMutation) BusinessID() (id int, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) BusinessIDs() (ids []int) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *AddressMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Prefecture != nil {
		fields = append(fields, address.FieldPrefecture)
	}
	if m._City != nil {
		fields = append(fields, address.FieldCity)
	}
	if m._Postcode != nil {
		fields = append(fields, address.FieldPostcode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldPrefecture:
		return m.Prefecture()
	case address.FieldCity:
		return m.City()
	case address.FieldPostcode:
		return m.Postcode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldPrefecture:
		return m.OldPrefecture(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldPostcode:
		return m.OldPostcode(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldPrefecture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefecture(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldPostcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostcode(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldPrefecture) {
		fields = append(fields, address.FieldPrefecture)
	}
	if m.FieldCleared(address.FieldCity) {
		fields = append(fields, address.FieldCity)
	}
	if m.FieldCleared(address.FieldPostcode) {
		fields = append(fields, address.FieldPostcode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldPrefecture:
		m.ClearPrefecture()
		return nil
	case address.FieldCity:
		m.ClearCity()
		return nil
	case address.FieldPostcode:
		m.ClearPostcode()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldPrefecture:
		m.ResetPrefecture()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldPostcode:
		m.ResetPostcode()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.business != nil {
		edges = append(edges, address.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbusiness {
		edges = append(edges, address.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Name           *string
	_WebsiteLink    *string
	_Overview       *string
	clearedFields   map[string]struct{}
	provider        *int
	clearedprovider bool
	address         map[int]struct{}
	removedaddress  map[int]struct{}
	clearedaddress  bool
	done            bool
	oldValue        func(context.Context) (*Business, error)
	predicates      []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id int) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *BusinessMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *BusinessMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "Name" field.
func (m *BusinessMutation) ClearName() {
	m._Name = nil
	m.clearedFields[business.FieldName] = struct{}{}
}

// NameCleared returns if the "Name" field was cleared in this mutation.
func (m *BusinessMutation) NameCleared() bool {
	_, ok := m.clearedFields[business.FieldName]
	return ok
}

// ResetName resets all changes to the "Name" field.
func (m *BusinessMutation) ResetName() {
	m._Name = nil
	delete(m.clearedFields, business.FieldName)
}

// SetWebsiteLink sets the "WebsiteLink" field.
func (m *BusinessMutation) SetWebsiteLink(s string) {
	m._WebsiteLink = &s
}

// WebsiteLink returns the value of the "WebsiteLink" field in the mutation.
func (m *BusinessMutation) WebsiteLink() (r string, exists bool) {
	v := m._WebsiteLink
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteLink returns the old "WebsiteLink" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldWebsiteLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteLink: %w", err)
	}
	return oldValue.WebsiteLink, nil
}

// ClearWebsiteLink clears the value of the "WebsiteLink" field.
func (m *BusinessMutation) ClearWebsiteLink() {
	m._WebsiteLink = nil
	m.clearedFields[business.FieldWebsiteLink] = struct{}{}
}

// WebsiteLinkCleared returns if the "WebsiteLink" field was cleared in this mutation.
func (m *BusinessMutation) WebsiteLinkCleared() bool {
	_, ok := m.clearedFields[business.FieldWebsiteLink]
	return ok
}

// ResetWebsiteLink resets all changes to the "WebsiteLink" field.
func (m *BusinessMutation) ResetWebsiteLink() {
	m._WebsiteLink = nil
	delete(m.clearedFields, business.FieldWebsiteLink)
}

// SetOverview sets the "Overview" field.
func (m *BusinessMutation) SetOverview(s string) {
	m._Overview = &s
}

// Overview returns the value of the "Overview" field in the mutation.
func (m *BusinessMutation) Overview() (r string, exists bool) {
	v := m._Overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "Overview" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ClearOverview clears the value of the "Overview" field.
func (m *BusinessMutation) ClearOverview() {
	m._Overview = nil
	m.clearedFields[business.FieldOverview] = struct{}{}
}

// OverviewCleared returns if the "Overview" field was cleared in this mutation.
func (m *BusinessMutation) OverviewCleared() bool {
	_, ok := m.clearedFields[business.FieldOverview]
	return ok
}

// ResetOverview resets all changes to the "Overview" field.
func (m *BusinessMutation) ResetOverview() {
	m._Overview = nil
	delete(m.clearedFields, business.FieldOverview)
}

// SetProviderID sets the "provider" edge to the Provider entity by id.
func (m *BusinessMutation) SetProviderID(id int) {
	m.provider = &id
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *BusinessMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *BusinessMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderID returns the "provider" edge ID in the mutation.
func (m *BusinessMutation) ProviderID() (id int, exists bool) {
	if m.provider != nil {
		return *m.provider, true
	}
	return
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) ProviderIDs() (ids []int) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *BusinessMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// AddAddresIDs adds the "address" edge to the Address entity by ids.
func (m *BusinessMutation) AddAddresIDs(ids ...int) {
	if m.address == nil {
		m.address = make(map[int]struct{})
	}
	for i := range ids {
		m.address[ids[i]] = struct{}{}
	}
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *BusinessMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *BusinessMutation) AddressCleared() bool {
	return m.clearedaddress
}

// RemoveAddresIDs removes the "address" edge to the Address entity by IDs.
func (m *BusinessMutation) RemoveAddresIDs(ids ...int) {
	if m.removedaddress == nil {
		m.removedaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.address, ids[i])
		m.removedaddress[ids[i]] = struct{}{}
	}
}

// RemovedAddress returns the removed IDs of the "address" edge to the Address entity.
func (m *BusinessMutation) RemovedAddressIDs() (ids []int) {
	for id := range m.removedaddress {
		ids = append(ids, id)
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
func (m *BusinessMutation) AddressIDs() (ids []int) {
	for id := range m.address {
		ids = append(ids, id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *BusinessMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
	m.removedaddress = nil
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Business, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Name != nil {
		fields = append(fields, business.FieldName)
	}
	if m._WebsiteLink != nil {
		fields = append(fields, business.FieldWebsiteLink)
	}
	if m._Overview != nil {
		fields = append(fields, business.FieldOverview)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldName:
		return m.Name()
	case business.FieldWebsiteLink:
		return m.WebsiteLink()
	case business.FieldOverview:
		return m.Overview()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldName:
		return m.OldName(ctx)
	case business.FieldWebsiteLink:
		return m.OldWebsiteLink(ctx)
	case business.FieldOverview:
		return m.OldOverview(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case business.FieldWebsiteLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteLink(v)
		return nil
	case business.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldName) {
		fields = append(fields, business.FieldName)
	}
	if m.FieldCleared(business.FieldWebsiteLink) {
		fields = append(fields, business.FieldWebsiteLink)
	}
	if m.FieldCleared(business.FieldOverview) {
		fields = append(fields, business.FieldOverview)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldName:
		m.ClearName()
		return nil
	case business.FieldWebsiteLink:
		m.ClearWebsiteLink()
		return nil
	case business.FieldOverview:
		m.ClearOverview()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldName:
		m.ResetName()
		return nil
	case business.FieldWebsiteLink:
		m.ResetWebsiteLink()
		return nil
	case business.FieldOverview:
		m.ResetOverview()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.provider != nil {
		edges = append(edges, business.EdgeProvider)
	}
	if m.address != nil {
		edges = append(edges, business.EdgeAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.address))
		for id := range m.address {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaddress != nil {
		edges = append(edges, business.EdgeAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.removedaddress))
		for id := range m.removedaddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprovider {
		edges = append(edges, business.EdgeProvider)
	}
	if m.clearedaddress {
		edges = append(edges, business.EdgeAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case business.EdgeProvider:
		return m.clearedprovider
	case business.EdgeAddress:
		return m.clearedaddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	switch name {
	case business.EdgeProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	switch name {
	case business.EdgeProvider:
		m.ResetProvider()
		return nil
	case business.EdgeAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown Business edge %s", name)
}

// CallerMutation represents an operation that mutates the Caller nodes in the graph.
type CallerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_IsFraud       *bool
	_FraudScore    *int
	add_FraudScore *int
	clearedFields  map[string]struct{}
	number         map[int]struct{}
	removednumber  map[int]struct{}
	clearednumber  bool
	done           bool
	oldValue       func(context.Context) (*Caller, error)
	predicates     []predicate.Caller
}

var _ ent.Mutation = (*CallerMutation)(nil)

// callerOption allows management of the mutation configuration using functional options.
type callerOption func(*CallerMutation)

// newCallerMutation creates new mutation for the Caller entity.
func newCallerMutation(c config, op Op, opts ...callerOption) *CallerMutation {
	m := &CallerMutation{
		config:        c,
		op:            op,
		typ:           TypeCaller,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCallerID sets the ID field of the mutation.
func withCallerID(id int) callerOption {
	return func(m *CallerMutation) {
		var (
			err   error
			once  sync.Once
			value *Caller
		)
		m.oldValue = func(ctx context.Context) (*Caller, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Caller.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCaller sets the old Caller of the mutation.
func withCaller(node *Caller) callerOption {
	return func(m *CallerMutation) {
		m.oldValue = func(context.Context) (*Caller, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CallerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CallerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CallerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CallerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Caller.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsFraud sets the "IsFraud" field.
func (m *CallerMutation) SetIsFraud(b bool) {
	m._IsFraud = &b
}

// IsFraud returns the value of the "IsFraud" field in the mutation.
func (m *CallerMutation) IsFraud() (r bool, exists bool) {
	v := m._IsFraud
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFraud returns the old "IsFraud" field's value of the Caller entity.
// If the Caller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallerMutation) OldIsFraud(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFraud is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFraud requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFraud: %w", err)
	}
	return oldValue.IsFraud, nil
}

// ResetIsFraud resets all changes to the "IsFraud" field.
func (m *CallerMutation) ResetIsFraud() {
	m._IsFraud = nil
}

// SetFraudScore sets the "FraudScore" field.
func (m *CallerMutation) SetFraudScore(i int) {
	m._FraudScore = &i
	m.add_FraudScore = nil
}

// FraudScore returns the value of the "FraudScore" field in the mutation.
func (m *CallerMutation) FraudScore() (r int, exists bool) {
	v := m._FraudScore
	if v == nil {
		return
	}
	return *v, true
}

// OldFraudScore returns the old "FraudScore" field's value of the Caller entity.
// If the Caller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CallerMutation) OldFraudScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFraudScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFraudScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFraudScore: %w", err)
	}
	return oldValue.FraudScore, nil
}

// AddFraudScore adds i to the "FraudScore" field.
func (m *CallerMutation) AddFraudScore(i int) {
	if m.add_FraudScore != nil {
		*m.add_FraudScore += i
	} else {
		m.add_FraudScore = &i
	}
}

// AddedFraudScore returns the value that was added to the "FraudScore" field in this mutation.
func (m *CallerMutation) AddedFraudScore() (r int, exists bool) {
	v := m.add_FraudScore
	if v == nil {
		return
	}
	return *v, true
}

// ResetFraudScore resets all changes to the "FraudScore" field.
func (m *CallerMutation) ResetFraudScore() {
	m._FraudScore = nil
	m.add_FraudScore = nil
}

// AddNumberIDs adds the "number" edge to the Number entity by ids.
func (m *CallerMutation) AddNumberIDs(ids ...int) {
	if m.number == nil {
		m.number = make(map[int]struct{})
	}
	for i := range ids {
		m.number[ids[i]] = struct{}{}
	}
}

// ClearNumber clears the "number" edge to the Number entity.
func (m *CallerMutation) ClearNumber() {
	m.clearednumber = true
}

// NumberCleared reports if the "number" edge to the Number entity was cleared.
func (m *CallerMutation) NumberCleared() bool {
	return m.clearednumber
}

// RemoveNumberIDs removes the "number" edge to the Number entity by IDs.
func (m *CallerMutation) RemoveNumberIDs(ids ...int) {
	if m.removednumber == nil {
		m.removednumber = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.number, ids[i])
		m.removednumber[ids[i]] = struct{}{}
	}
}

// RemovedNumber returns the removed IDs of the "number" edge to the Number entity.
func (m *CallerMutation) RemovedNumberIDs() (ids []int) {
	for id := range m.removednumber {
		ids = append(ids, id)
	}
	return
}

// NumberIDs returns the "number" edge IDs in the mutation.
func (m *CallerMutation) NumberIDs() (ids []int) {
	for id := range m.number {
		ids = append(ids, id)
	}
	return
}

// ResetNumber resets all changes to the "number" edge.
func (m *CallerMutation) ResetNumber() {
	m.number = nil
	m.clearednumber = false
	m.removednumber = nil
}

// Where appends a list predicates to the CallerMutation builder.
func (m *CallerMutation) Where(ps ...predicate.Caller) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CallerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CallerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Caller, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CallerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CallerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Caller).
func (m *CallerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CallerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._IsFraud != nil {
		fields = append(fields, caller.FieldIsFraud)
	}
	if m._FraudScore != nil {
		fields = append(fields, caller.FieldFraudScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CallerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case caller.FieldIsFraud:
		return m.IsFraud()
	case caller.FieldFraudScore:
		return m.FraudScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CallerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case caller.FieldIsFraud:
		return m.OldIsFraud(ctx)
	case caller.FieldFraudScore:
		return m.OldFraudScore(ctx)
	}
	return nil, fmt.Errorf("unknown Caller field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case caller.FieldIsFraud:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFraud(v)
		return nil
	case caller.FieldFraudScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFraudScore(v)
		return nil
	}
	return fmt.Errorf("unknown Caller field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CallerMutation) AddedFields() []string {
	var fields []string
	if m.add_FraudScore != nil {
		fields = append(fields, caller.FieldFraudScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CallerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case caller.FieldFraudScore:
		return m.AddedFraudScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case caller.FieldFraudScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFraudScore(v)
		return nil
	}
	return fmt.Errorf("unknown Caller numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CallerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CallerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CallerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Caller nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CallerMutation) ResetField(name string) error {
	switch name {
	case caller.FieldIsFraud:
		m.ResetIsFraud()
		return nil
	case caller.FieldFraudScore:
		m.ResetFraudScore()
		return nil
	}
	return fmt.Errorf("unknown Caller field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CallerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.number != nil {
		edges = append(edges, caller.EdgeNumber)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CallerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case caller.EdgeNumber:
		ids := make([]ent.Value, 0, len(m.number))
		for id := range m.number {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CallerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednumber != nil {
		edges = append(edges, caller.EdgeNumber)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CallerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case caller.EdgeNumber:
		ids := make([]ent.Value, 0, len(m.removednumber))
		for id := range m.removednumber {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CallerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednumber {
		edges = append(edges, caller.EdgeNumber)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CallerMutation) EdgeCleared(name string) bool {
	switch name {
	case caller.EdgeNumber:
		return m.clearednumber
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CallerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Caller unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CallerMutation) ResetEdge(name string) error {
	switch name {
	case caller.EdgeNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown Caller edge %s", name)
}

// CarrierMutation represents an operation that mutates the Carrier nodes in the graph.
type CarrierMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	clearedFields map[string]struct{}
	number        map[int]struct{}
	removednumber map[int]struct{}
	clearednumber bool
	done          bool
	oldValue      func(context.Context) (*Carrier, error)
	predicates    []predicate.Carrier
}

var _ ent.Mutation = (*CarrierMutation)(nil)

// carrierOption allows management of the mutation configuration using functional options.
type carrierOption func(*CarrierMutation)

// newCarrierMutation creates new mutation for the Carrier entity.
func newCarrierMutation(c config, op Op, opts ...carrierOption) *CarrierMutation {
	m := &CarrierMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierID sets the ID field of the mutation.
func withCarrierID(id int) carrierOption {
	return func(m *CarrierMutation) {
		var (
			err   error
			once  sync.Once
			value *Carrier
		)
		m.oldValue = func(ctx context.Context) (*Carrier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Carrier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrier sets the old Carrier of the mutation.
func withCarrier(node *Carrier) carrierOption {
	return func(m *CarrierMutation) {
		m.oldValue = func(context.Context) (*Carrier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Carrier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *CarrierMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *CarrierMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Carrier entity.
// If the Carrier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "Name" field.
func (m *CarrierMutation) ClearName() {
	m._Name = nil
	m.clearedFields[carrier.FieldName] = struct{}{}
}

// NameCleared returns if the "Name" field was cleared in this mutation.
func (m *CarrierMutation) NameCleared() bool {
	_, ok := m.clearedFields[carrier.FieldName]
	return ok
}

// ResetName resets all changes to the "Name" field.
func (m *CarrierMutation) ResetName() {
	m._Name = nil
	delete(m.clearedFields, carrier.FieldName)
}

// AddNumberIDs adds the "number" edge to the Number entity by ids.
func (m *CarrierMutation) AddNumberIDs(ids ...int) {
	if m.number == nil {
		m.number = make(map[int]struct{})
	}
	for i := range ids {
		m.number[ids[i]] = struct{}{}
	}
}

// ClearNumber clears the "number" edge to the Number entity.
func (m *CarrierMutation) ClearNumber() {
	m.clearednumber = true
}

// NumberCleared reports if the "number" edge to the Number entity was cleared.
func (m *CarrierMutation) NumberCleared() bool {
	return m.clearednumber
}

// RemoveNumberIDs removes the "number" edge to the Number entity by IDs.
func (m *CarrierMutation) RemoveNumberIDs(ids ...int) {
	if m.removednumber == nil {
		m.removednumber = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.number, ids[i])
		m.removednumber[ids[i]] = struct{}{}
	}
}

// RemovedNumber returns the removed IDs of the "number" edge to the Number entity.
func (m *CarrierMutation) RemovedNumberIDs() (ids []int) {
	for id := range m.removednumber {
		ids = append(ids, id)
	}
	return
}

// NumberIDs returns the "number" edge IDs in the mutation.
func (m *CarrierMutation) NumberIDs() (ids []int) {
	for id := range m.number {
		ids = append(ids, id)
	}
	return
}

// ResetNumber resets all changes to the "number" edge.
func (m *CarrierMutation) ResetNumber() {
	m.number = nil
	m.clearednumber = false
	m.removednumber = nil
}

// Where appends a list predicates to the CarrierMutation builder.
func (m *CarrierMutation) Where(ps ...predicate.Carrier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Carrier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Carrier).
func (m *CarrierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, carrier.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrier.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrier.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Carrier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Carrier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Carrier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carrier.FieldName) {
		fields = append(fields, carrier.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierMutation) ClearField(name string) error {
	switch name {
	case carrier.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Carrier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierMutation) ResetField(name string) error {
	switch name {
	case carrier.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Carrier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.number != nil {
		edges = append(edges, carrier.EdgeNumber)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrier.EdgeNumber:
		ids := make([]ent.Value, 0, len(m.number))
		for id := range m.number {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednumber != nil {
		edges = append(edges, carrier.EdgeNumber)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrier.EdgeNumber:
		ids := make([]ent.Value, 0, len(m.removednumber))
		for id := range m.removednumber {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednumber {
		edges = append(edges, carrier.EdgeNumber)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierMutation) EdgeCleared(name string) bool {
	switch name {
	case carrier.EdgeNumber:
		return m.clearednumber
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Carrier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierMutation) ResetEdge(name string) error {
	switch name {
	case carrier.EdgeNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown Carrier edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_PostDate             *time.Time
	_CommentText          *string
	_CommentFraudScore    *int
	add_CommentFraudScore *int
	clearedFields         map[string]struct{}
	provider              *int
	clearedprovider       bool
	done                  bool
	oldValue              func(context.Context) (*Comment, error)
	predicates            []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPostDate sets the "PostDate" field.
func (m *CommentMutation) SetPostDate(t time.Time) {
	m._PostDate = &t
}

// PostDate returns the value of the "PostDate" field in the mutation.
func (m *CommentMutation) PostDate() (r time.Time, exists bool) {
	v := m._PostDate
	if v == nil {
		return
	}
	return *v, true
}

// OldPostDate returns the old "PostDate" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPostDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostDate: %w", err)
	}
	return oldValue.PostDate, nil
}

// ResetPostDate resets all changes to the "PostDate" field.
func (m *CommentMutation) ResetPostDate() {
	m._PostDate = nil
}

// SetCommentText sets the "CommentText" field.
func (m *CommentMutation) SetCommentText(s string) {
	m._CommentText = &s
}

// CommentText returns the value of the "CommentText" field in the mutation.
func (m *CommentMutation) CommentText() (r string, exists bool) {
	v := m._CommentText
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentText returns the old "CommentText" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCommentText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentText: %w", err)
	}
	return oldValue.CommentText, nil
}

// ResetCommentText resets all changes to the "CommentText" field.
func (m *CommentMutation) ResetCommentText() {
	m._CommentText = nil
}

// SetCommentFraudScore sets the "CommentFraudScore" field.
func (m *CommentMutation) SetCommentFraudScore(i int) {
	m._CommentFraudScore = &i
	m.add_CommentFraudScore = nil
}

// CommentFraudScore returns the value of the "CommentFraudScore" field in the mutation.
func (m *CommentMutation) CommentFraudScore() (r int, exists bool) {
	v := m._CommentFraudScore
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentFraudScore returns the old "CommentFraudScore" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCommentFraudScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentFraudScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentFraudScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentFraudScore: %w", err)
	}
	return oldValue.CommentFraudScore, nil
}

// AddCommentFraudScore adds i to the "CommentFraudScore" field.
func (m *CommentMutation) AddCommentFraudScore(i int) {
	if m.add_CommentFraudScore != nil {
		*m.add_CommentFraudScore += i
	} else {
		m.add_CommentFraudScore = &i
	}
}

// AddedCommentFraudScore returns the value that was added to the "CommentFraudScore" field in this mutation.
func (m *CommentMutation) AddedCommentFraudScore() (r int, exists bool) {
	v := m.add_CommentFraudScore
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentFraudScore resets all changes to the "CommentFraudScore" field.
func (m *CommentMutation) ResetCommentFraudScore() {
	m._CommentFraudScore = nil
	m.add_CommentFraudScore = nil
}

// SetProviderID sets the "provider" edge to the Provider entity by id.
func (m *CommentMutation) SetProviderID(id int) {
	m.provider = &id
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *CommentMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *CommentMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderID returns the "provider" edge ID in the mutation.
func (m *CommentMutation) ProviderID() (id int, exists bool) {
	if m.provider != nil {
		return *m.provider, true
	}
	return
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ProviderIDs() (ids []int) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *CommentMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._PostDate != nil {
		fields = append(fields, comment.FieldPostDate)
	}
	if m._CommentText != nil {
		fields = append(fields, comment.FieldCommentText)
	}
	if m._CommentFraudScore != nil {
		fields = append(fields, comment.FieldCommentFraudScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldPostDate:
		return m.PostDate()
	case comment.FieldCommentText:
		return m.CommentText()
	case comment.FieldCommentFraudScore:
		return m.CommentFraudScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldPostDate:
		return m.OldPostDate(ctx)
	case comment.FieldCommentText:
		return m.OldCommentText(ctx)
	case comment.FieldCommentFraudScore:
		return m.OldCommentFraudScore(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldPostDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostDate(v)
		return nil
	case comment.FieldCommentText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentText(v)
		return nil
	case comment.FieldCommentFraudScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentFraudScore(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.add_CommentFraudScore != nil {
		fields = append(fields, comment.FieldCommentFraudScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCommentFraudScore:
		return m.AddedCommentFraudScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCommentFraudScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentFraudScore(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldPostDate:
		m.ResetPostDate()
		return nil
	case comment.FieldCommentText:
		m.ResetCommentText()
		return nil
	case comment.FieldCommentFraudScore:
		m.ResetCommentFraudScore()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.provider != nil {
		edges = append(edges, comment.EdgeProvider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprovider {
		edges = append(edges, comment.EdgeProvider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeProvider:
		return m.clearedprovider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// LineTypeMutation represents an operation that mutates the LineType nodes in the graph.
type LineTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_LineType     *providers.LineType
	clearedFields map[string]struct{}
	number        map[int]struct{}
	removednumber map[int]struct{}
	clearednumber bool
	done          bool
	oldValue      func(context.Context) (*LineType, error)
	predicates    []predicate.LineType
}

var _ ent.Mutation = (*LineTypeMutation)(nil)

// linetypeOption allows management of the mutation configuration using functional options.
type linetypeOption func(*LineTypeMutation)

// newLineTypeMutation creates new mutation for the LineType entity.
func newLineTypeMutation(c config, op Op, opts ...linetypeOption) *LineTypeMutation {
	m := &LineTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeLineType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLineTypeID sets the ID field of the mutation.
func withLineTypeID(id int) linetypeOption {
	return func(m *LineTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *LineType
		)
		m.oldValue = func(ctx context.Context) (*LineType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LineType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLineType sets the old LineType of the mutation.
func withLineType(node *LineType) linetypeOption {
	return func(m *LineTypeMutation) {
		m.oldValue = func(context.Context) (*LineType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LineTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LineTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LineTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LineTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LineType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLineType sets the "LineType" field.
func (m *LineTypeMutation) SetLineType(pt providers.LineType) {
	m._LineType = &pt
}

// LineType returns the value of the "LineType" field in the mutation.
func (m *LineTypeMutation) LineType() (r providers.LineType, exists bool) {
	v := m._LineType
	if v == nil {
		return
	}
	return *v, true
}

// OldLineType returns the old "LineType" field's value of the LineType entity.
// If the LineType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LineTypeMutation) OldLineType(ctx context.Context) (v providers.LineType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineType: %w", err)
	}
	return oldValue.LineType, nil
}

// ResetLineType resets all changes to the "LineType" field.
func (m *LineTypeMutation) ResetLineType() {
	m._LineType = nil
}

// AddNumberIDs adds the "number" edge to the Number entity by ids.
func (m *LineTypeMutation) AddNumberIDs(ids ...int) {
	if m.number == nil {
		m.number = make(map[int]struct{})
	}
	for i := range ids {
		m.number[ids[i]] = struct{}{}
	}
}

// ClearNumber clears the "number" edge to the Number entity.
func (m *LineTypeMutation) ClearNumber() {
	m.clearednumber = true
}

// NumberCleared reports if the "number" edge to the Number entity was cleared.
func (m *LineTypeMutation) NumberCleared() bool {
	return m.clearednumber
}

// RemoveNumberIDs removes the "number" edge to the Number entity by IDs.
func (m *LineTypeMutation) RemoveNumberIDs(ids ...int) {
	if m.removednumber == nil {
		m.removednumber = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.number, ids[i])
		m.removednumber[ids[i]] = struct{}{}
	}
}

// RemovedNumber returns the removed IDs of the "number" edge to the Number entity.
func (m *LineTypeMutation) RemovedNumberIDs() (ids []int) {
	for id := range m.removednumber {
		ids = append(ids, id)
	}
	return
}

// NumberIDs returns the "number" edge IDs in the mutation.
func (m *LineTypeMutation) NumberIDs() (ids []int) {
	for id := range m.number {
		ids = append(ids, id)
	}
	return
}

// ResetNumber resets all changes to the "number" edge.
func (m *LineTypeMutation) ResetNumber() {
	m.number = nil
	m.clearednumber = false
	m.removednumber = nil
}

// Where appends a list predicates to the LineTypeMutation builder.
func (m *LineTypeMutation) Where(ps ...predicate.LineType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LineTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LineTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LineType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LineTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LineTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LineType).
func (m *LineTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LineTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._LineType != nil {
		fields = append(fields, linetype.FieldLineType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LineTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case linetype.FieldLineType:
		return m.LineType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LineTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case linetype.FieldLineType:
		return m.OldLineType(ctx)
	}
	return nil, fmt.Errorf("unknown LineType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LineTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case linetype.FieldLineType:
		v, ok := value.(providers.LineType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineType(v)
		return nil
	}
	return fmt.Errorf("unknown LineType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LineTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LineTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LineTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LineType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LineTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LineTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LineTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LineType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LineTypeMutation) ResetField(name string) error {
	switch name {
	case linetype.FieldLineType:
		m.ResetLineType()
		return nil
	}
	return fmt.Errorf("unknown LineType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LineTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.number != nil {
		edges = append(edges, linetype.EdgeNumber)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LineTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case linetype.EdgeNumber:
		ids := make([]ent.Value, 0, len(m.number))
		for id := range m.number {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LineTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednumber != nil {
		edges = append(edges, linetype.EdgeNumber)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LineTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case linetype.EdgeNumber:
		ids := make([]ent.Value, 0, len(m.removednumber))
		for id := range m.removednumber {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LineTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednumber {
		edges = append(edges, linetype.EdgeNumber)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LineTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case linetype.EdgeNumber:
		return m.clearednumber
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LineTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LineType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LineTypeMutation) ResetEdge(name string) error {
	switch name {
	case linetype.EdgeNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown LineType edge %s", name)
}

// NumberMutation represents an operation that mutates the Number nodes in the graph.
type NumberMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Number         *string
	clearedFields   map[string]struct{}
	caller          *int
	clearedcaller   bool
	linetype        *int
	clearedlinetype bool
	carrier         *int
	clearedcarrier  bool
	provider        map[int]struct{}
	removedprovider map[int]struct{}
	clearedprovider bool
	done            bool
	oldValue        func(context.Context) (*Number, error)
	predicates      []predicate.Number
}

var _ ent.Mutation = (*NumberMutation)(nil)

// numberOption allows management of the mutation configuration using functional options.
type numberOption func(*NumberMutation)

// newNumberMutation creates new mutation for the Number entity.
func newNumberMutation(c config, op Op, opts ...numberOption) *NumberMutation {
	m := &NumberMutation{
		config:        c,
		op:            op,
		typ:           TypeNumber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNumberID sets the ID field of the mutation.
func withNumberID(id int) numberOption {
	return func(m *NumberMutation) {
		var (
			err   error
			once  sync.Once
			value *Number
		)
		m.oldValue = func(ctx context.Context) (*Number, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Number.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNumber sets the old Number of the mutation.
func withNumber(node *Number) numberOption {
	return func(m *NumberMutation) {
		m.oldValue = func(context.Context) (*Number, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NumberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NumberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NumberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NumberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Number.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumber sets the "Number" field.
func (m *NumberMutation) SetNumber(s string) {
	m._Number = &s
}

// Number returns the value of the "Number" field in the mutation.
func (m *NumberMutation) Number() (r string, exists bool) {
	v := m._Number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "Number" field's value of the Number entity.
// If the Number object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NumberMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "Number" field.
func (m *NumberMutation) ResetNumber() {
	m._Number = nil
}

// SetCallerID sets the "caller" edge to the Caller entity by id.
func (m *NumberMutation) SetCallerID(id int) {
	m.caller = &id
}

// ClearCaller clears the "caller" edge to the Caller entity.
func (m *NumberMutation) ClearCaller() {
	m.clearedcaller = true
}

// CallerCleared reports if the "caller" edge to the Caller entity was cleared.
func (m *NumberMutation) CallerCleared() bool {
	return m.clearedcaller
}

// CallerID returns the "caller" edge ID in the mutation.
func (m *NumberMutation) CallerID() (id int, exists bool) {
	if m.caller != nil {
		return *m.caller, true
	}
	return
}

// CallerIDs returns the "caller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallerID instead. It exists only for internal usage by the builders.
func (m *NumberMutation) CallerIDs() (ids []int) {
	if id := m.caller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCaller resets all changes to the "caller" edge.
func (m *NumberMutation) ResetCaller() {
	m.caller = nil
	m.clearedcaller = false
}

// SetLinetypeID sets the "linetype" edge to the LineType entity by id.
func (m *NumberMutation) SetLinetypeID(id int) {
	m.linetype = &id
}

// ClearLinetype clears the "linetype" edge to the LineType entity.
func (m *NumberMutation) ClearLinetype() {
	m.clearedlinetype = true
}

// LinetypeCleared reports if the "linetype" edge to the LineType entity was cleared.
func (m *NumberMutation) LinetypeCleared() bool {
	return m.clearedlinetype
}

// LinetypeID returns the "linetype" edge ID in the mutation.
func (m *NumberMutation) LinetypeID() (id int, exists bool) {
	if m.linetype != nil {
		return *m.linetype, true
	}
	return
}

// LinetypeIDs returns the "linetype" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinetypeID instead. It exists only for internal usage by the builders.
func (m *NumberMutation) LinetypeIDs() (ids []int) {
	if id := m.linetype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLinetype resets all changes to the "linetype" edge.
func (m *NumberMutation) ResetLinetype() {
	m.linetype = nil
	m.clearedlinetype = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *NumberMutation) SetCarrierID(id int) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *NumberMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *NumberMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *NumberMutation) CarrierID() (id int, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *NumberMutation) CarrierIDs() (ids []int) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *NumberMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// AddProviderIDs adds the "provider" edge to the Provider entity by ids.
func (m *NumberMutation) AddProviderIDs(ids ...int) {
	if m.provider == nil {
		m.provider = make(map[int]struct{})
	}
	for i := range ids {
		m.provider[ids[i]] = struct{}{}
	}
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *NumberMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *NumberMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// RemoveProviderIDs removes the "provider" edge to the Provider entity by IDs.
func (m *NumberMutation) RemoveProviderIDs(ids ...int) {
	if m.removedprovider == nil {
		m.removedprovider = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.provider, ids[i])
		m.removedprovider[ids[i]] = struct{}{}
	}
}

// RemovedProvider returns the removed IDs of the "provider" edge to the Provider entity.
func (m *NumberMutation) RemovedProviderIDs() (ids []int) {
	for id := range m.removedprovider {
		ids = append(ids, id)
	}
	return
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
func (m *NumberMutation) ProviderIDs() (ids []int) {
	for id := range m.provider {
		ids = append(ids, id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *NumberMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
	m.removedprovider = nil
}

// Where appends a list predicates to the NumberMutation builder.
func (m *NumberMutation) Where(ps ...predicate.Number) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NumberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NumberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Number, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NumberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NumberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Number).
func (m *NumberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NumberMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Number != nil {
		fields = append(fields, number.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NumberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case number.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NumberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case number.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Number field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NumberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case number.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Number field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NumberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NumberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NumberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Number numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NumberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NumberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NumberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Number nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NumberMutation) ResetField(name string) error {
	switch name {
	case number.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown Number field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NumberMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.caller != nil {
		edges = append(edges, number.EdgeCaller)
	}
	if m.linetype != nil {
		edges = append(edges, number.EdgeLinetype)
	}
	if m.carrier != nil {
		edges = append(edges, number.EdgeCarrier)
	}
	if m.provider != nil {
		edges = append(edges, number.EdgeProvider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NumberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case number.EdgeCaller:
		if id := m.caller; id != nil {
			return []ent.Value{*id}
		}
	case number.EdgeLinetype:
		if id := m.linetype; id != nil {
			return []ent.Value{*id}
		}
	case number.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	case number.EdgeProvider:
		ids := make([]ent.Value, 0, len(m.provider))
		for id := range m.provider {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NumberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedprovider != nil {
		edges = append(edges, number.EdgeProvider)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NumberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case number.EdgeProvider:
		ids := make([]ent.Value, 0, len(m.removedprovider))
		for id := range m.removedprovider {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NumberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcaller {
		edges = append(edges, number.EdgeCaller)
	}
	if m.clearedlinetype {
		edges = append(edges, number.EdgeLinetype)
	}
	if m.clearedcarrier {
		edges = append(edges, number.EdgeCarrier)
	}
	if m.clearedprovider {
		edges = append(edges, number.EdgeProvider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NumberMutation) EdgeCleared(name string) bool {
	switch name {
	case number.EdgeCaller:
		return m.clearedcaller
	case number.EdgeLinetype:
		return m.clearedlinetype
	case number.EdgeCarrier:
		return m.clearedcarrier
	case number.EdgeProvider:
		return m.clearedprovider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NumberMutation) ClearEdge(name string) error {
	switch name {
	case number.EdgeCaller:
		m.ClearCaller()
		return nil
	case number.EdgeLinetype:
		m.ClearLinetype()
		return nil
	case number.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown Number unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NumberMutation) ResetEdge(name string) error {
	switch name {
	case number.EdgeCaller:
		m.ResetCaller()
		return nil
	case number.EdgeLinetype:
		m.ResetLinetype()
		return nil
	case number.EdgeCarrier:
		m.ResetCarrier()
		return nil
	case number.EdgeProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown Number edge %s", name)
}

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Name           *string
	clearedFields   map[string]struct{}
	number          *int
	clearednumber   bool
	comment         map[int]struct{}
	removedcomment  map[int]struct{}
	clearedcomment  bool
	business        *int
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*Provider, error)
	predicates      []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id int) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *ProviderMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProviderMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProviderMutation) ResetName() {
	m._Name = nil
}

// SetNumberID sets the "number" edge to the Number entity by id.
func (m *ProviderMutation) SetNumberID(id int) {
	m.number = &id
}

// ClearNumber clears the "number" edge to the Number entity.
func (m *ProviderMutation) ClearNumber() {
	m.clearednumber = true
}

// NumberCleared reports if the "number" edge to the Number entity was cleared.
func (m *ProviderMutation) NumberCleared() bool {
	return m.clearednumber
}

// NumberID returns the "number" edge ID in the mutation.
func (m *ProviderMutation) NumberID() (id int, exists bool) {
	if m.number != nil {
		return *m.number, true
	}
	return
}

// NumberIDs returns the "number" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NumberID instead. It exists only for internal usage by the builders.
func (m *ProviderMutation) NumberIDs() (ids []int) {
	if id := m.number; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNumber resets all changes to the "number" edge.
func (m *ProviderMutation) ResetNumber() {
	m.number = nil
	m.clearednumber = false
}

// AddCommentIDs adds the "comment" edge to the Comment entity by ids.
func (m *ProviderMutation) AddCommentIDs(ids ...int) {
	if m.comment == nil {
		m.comment = make(map[int]struct{})
	}
	for i := range ids {
		m.comment[ids[i]] = struct{}{}
	}
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *ProviderMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *ProviderMutation) CommentCleared() bool {
	return m.clearedcomment
}

// RemoveCommentIDs removes the "comment" edge to the Comment entity by IDs.
func (m *ProviderMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomment == nil {
		m.removedcomment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment, ids[i])
		m.removedcomment[ids[i]] = struct{}{}
	}
}

// RemovedComment returns the removed IDs of the "comment" edge to the Comment entity.
func (m *ProviderMutation) RemovedCommentIDs() (ids []int) {
	for id := range m.removedcomment {
		ids = append(ids, id)
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
func (m *ProviderMutation) CommentIDs() (ids []int) {
	for id := range m.comment {
		ids = append(ids, id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *ProviderMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
	m.removedcomment = nil
}

// SetBusinessID sets the "business" edge to the Business entity by id.
func (m *ProviderMutation) SetBusinessID(id int) {
	m.business = &id
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *ProviderMutation) ClearBusiness() {
	m.clearedbusiness = true
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *ProviderMutation) BusinessCleared() bool {
	return m.clearedbusiness
}

// BusinessID returns the "business" edge ID in the mutation.
func (m *ProviderMutation) BusinessID() (id int, exists bool) {
	if m.business != nil {
		return *m.business, true
	}
	return
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *ProviderMutation) BusinessIDs() (ids []int) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *ProviderMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, provider.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.number != nil {
		edges = append(edges, provider.EdgeNumber)
	}
	if m.comment != nil {
		edges = append(edges, provider.EdgeComment)
	}
	if m.business != nil {
		edges = append(edges, provider.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeNumber:
		if id := m.number; id != nil {
			return []ent.Value{*id}
		}
	case provider.EdgeComment:
		ids := make([]ent.Value, 0, len(m.comment))
		for id := range m.comment {
			ids = append(ids, id)
		}
		return ids
	case provider.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcomment != nil {
		edges = append(edges, provider.EdgeComment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeComment:
		ids := make([]ent.Value, 0, len(m.removedcomment))
		for id := range m.removedcomment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednumber {
		edges = append(edges, provider.EdgeNumber)
	}
	if m.clearedcomment {
		edges = append(edges, provider.EdgeComment)
	}
	if m.clearedbusiness {
		edges = append(edges, provider.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case provider.EdgeNumber:
		return m.clearednumber
	case provider.EdgeComment:
		return m.clearedcomment
	case provider.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	switch name {
	case provider.EdgeNumber:
		m.ClearNumber()
		return nil
	case provider.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	switch name {
	case provider.EdgeNumber:
		m.ResetNumber()
		return nil
	case provider.EdgeComment:
		m.ResetComment()
		return nil
	case provider.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown Provider edge %s", name)
}
